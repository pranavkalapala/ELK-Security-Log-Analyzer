input {
  file {
    path => "/home/kali/Desktop/mac_logs_last_5m.json"
    start_position => "beginning"
    sincedb_path => "/dev/null"
    codec => "json"
  }
}

filter {
  # 1. DROP the header line which doesn't contain actual log data.
  if [log_message] =~ /^\s*Timestamp\s+\(process\)\[PID\]\s*$/ {
    drop {}
  }

  # 2. GROK Filter for Mac Log Format
  # Breaks the raw string in 'log_message' into structured fields:
  # timestamp_str, host, process, pid, and message (the log content).
  grok {
    match => { "log_message" => "%{TIMESTAMP_ISO8601:timestamp_str}\s+%{HOSTNAME:host}\s+%{DATA:process}(?:\[%{NONNEGINT:pid}\])?:%{SPACE}(?<message>.*)" }
    tag_on_failure => ["_maclogparsefailure"] 
  }
  
  # 3. DATE Filter
  # Parses the extracted timestamp string and sets the event's primary @timestamp field.
  date {
    match => ["timestamp_str", "YYYY-MM-dd HH:mm:ss.SSSSSSZ"]
    target => "@timestamp"
    remove_field => ["timestamp_str"] 
  }

  # 4. MUTATE (Type Coercion and Cleanup)
  mutate {
    # Ensure PID is an integer in Elasticsearch
    convert => { "pid" => "integer" }
    # Rename the original, raw log field
    rename => { "log_message" => "raw_log_line" }
  }
}

output {
  elasticsearch {
    hosts => ["http://localhost:9200"]
    # Targets the exact index you were querying
    index => "mac-logs-last-5m"
  }
  
  # Output parsed events to console for debugging
  stdout { codec => rubydebug }
}
